---
title: "TIL 250210"
description: "스프링 MVC - 서블릿, JSP, MVC 패턴 | 알고리즘 class 1 - 3문제 | CS 6-2, 6-3 정리 | EXP - 스프링 입문 3개"
filter: "🧣2025.02"
---

# What I did

스프링 MVC - 서블릿, JSP, MVC 패턴

알고리즘 class 1 - 3문제

CS 6-2, 6-3 정리

EXP - 스프링 입문 3개

# 배운점

## 알고리즘

2562, 2884, 10250

- `ArrayList<Interger> alists` 에서 바로 인덱스를 쓸 수 없음
    - alists.get[i] 로 불러옴
- `Math.max(a, b)` 도 쓸 수 있다. (import 없이)
- 헷갈린 부분 - sc.nextInt(); 하면 정수 1개를 인식함.
    - sc.nextInt(); sc.nextInt(); 하면 띄어쓰기, 줄 바꿈 상관 없이 정수 2개 인식.
- **`StringBuilder` - 문자열을 효율적으로 수정할 수 있는 클래스**
    
    ✅ **`String` 대신 `StringBuilder`를 쓰는 이유?**
    
    - `String`은 **불변(immutable)** → 문자열 수정 시 **새로운 객체 생성** (메모리 비효율적)
    - `StringBuilder`는 **가변(mutable)** → 기존 문자열을 **수정 가능** (속도 빠름)
    - **여러가지 기능**
        
        ```java
        StringBuilder sb = new StringBuilder("Hello");
        
        // 문자열 추가
        sb.append(" World"); // "Hello World"
        
        // 문자열 삽입
        sb.insert(5, ","); // "Hello, World"
        
        // 문자열 삭제
        sb.delete(5, 6); // "Hello World"
        
        // 문자열 변경
        sb.replace(6, 11, "Java"); // "Hello Java"
        
        // 뒤집기
        sb.reverse(); // "avaJ olleH"
        
        // 최종 문자열 변환
        String result = sb.toString(); // "avaJ olleH"
        ```
        

## 스프링 mvc

### 서블릿(요청 데이터 api 메시지 ~ 응답 데이터)

## HTTP 요청 데이터 - API 메시지 바디 (단순 텍스트)

- HTTP message body 에 데이터를 직접 담아서 요청
    - HTTP API에서 주로 사용, **JSON**, XML, TEXT
    - POST, PUT, PATCH

![image.png](attachment:91567dab-ba64-4c79-99da-aa3f78e2a1a4:image.png)

`RequestBodySpringServlet`

```java
@WebServlet (name = "RequestBodySpringServlet", urlPatterns = "/request-body-string")
public class RequestBodySpringServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        ServletInputStream inputStream = request.getInputStream();// 바디의 내용을 바로 바이트 코드로 바꿀 수 있다.
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        System.out.println("messageBody = " + messageBody);

        response.getWriter().write("ok");
```

![image.png](attachment:c2df13b7-293f-44f5-8016-67261a791887:image.png)

```bash
messageBody = hello!
```

## HTTP 요청 데이터 - API 메시지 바디 (JSON)

- POST http://localhost:8080/request-body-json
- content-type: application/json
- message body: `{”username”: “hello”, “age”: 20}`
- 결과 `message body = {”username": “hello”, “age”: 20}`

### **JSON 형식 파싱 추가**

`servlet/basic/HelloData`

```java
package hello.servlet.basic;

import lombok.Getter;
import lombok.Setter;

@Getter @Setter
public class HelloData {

    private String username;
    private int age;

}
```

`RequestBodyJsonServlet`

```java
@WebServlet(name = "requestBodyJsonServlet", urlPatterns = "/request-body-json")
public class RequestBodyJsonServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        ServletInputStream inputStream = request.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        System.out.println("messageBody = " + messageBody);

    }
}
```

![image.png](attachment:1e341d2f-da98-4b15-8b6f-249983932cd2:image.png)

```bash
messageBody = {"username": "hello", "age": 20}
```

### HelloData 라는 객체로 변환 - **ObjectMapper**

```java
@WebServlet(name = "requestBodyJsonServlet", urlPatterns = "/request-body-json")
public class RequestBodyJsonServlet extends HttpServlet {

    **private ObjectMapper objectMapper = new ObjectMapper();**

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        ServletInputStream inputStream = request.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        System.out.println("messageBody = " + messageBody);

        **HelloData helloData = objectMapper.readValue(messageBody, HelloData.class);
        System.out.println("helloData.getUsername() = " + helloData.getUsername());
        System.out.println("helloData.getAge() = " + helloData.getAge());**
    }
}
```

객체로도 잘 됨.

```bash
messageBody = {"username": "hello", "age": 20}
helloData.getUsername() = hello
helloData.getAge() = 20
```

- JSON 결과를 파싱해서 사용할 수 있는 자바 객체로 변환하려면 Jackson, Gson 같은 JSON 변환 라이브러리를 추가해서 사용해야 한다. 스프링 부트로 Spring MVC를 선택하면 기본으로 Jackson 라이브러리(`ObjectMapper`)를 함께 제공

## HTTPServletResponse

### 역할

**HTTP 응답 메시지 생성**

- HTTP 응답코드 지정 (200, 404 이런거)
- 헤더 생성
- 바디 생성
- +Content-Type, 쿠키, Redirect

### 기본 사용법

```java
package hello.servlet.basic.response;

@WebServlet(name = "responseHeaderServlet", urlPatterns = "/response-header")
public class ResponseHeaderServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //[status-line]
        response.setStatus(HttpServletResponse.SC_OK);

        //[response-headers]
        response.setHeader("Content-Type", "text/plain;charset=utf-8");
        response.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
        response.setHeader("Pragma", "no-cache");
        response.setHeader("my-header", "hello");
        
        //[header 편의 메서드]
        content(response);
        cookie(response);
        redirect(response);

        PrintWriter writer = response.getWriter();
        writer.println("ok"); //뒤에 enter가 들어가서 Content-Length:3으로 나옴

    }
}
```

setStatue(200); 이렇게 써도 되지만.. 

![image.png](attachment:dabfcfe2-6950-43bf-be66-562a337a52c9:image.png)

![image.png](attachment:6f702b4a-14ad-44d0-894e-931ddcdd35c8:image.png)

### 편의 메서드

**Content**

```java
    private void content(HttpServletResponse response) {
//        Content-Type: text/plain;charset=utf-8
//        Content-Length: 2
//        response.setHeader("Content-Type", "text/plain;charset=utf-8");
        response.setContentType("text/plain");
        response.setCharacterEncoding("utf-8");
//        response.setContentLength(2); //(생략시 자동 생성)
    }
```

**쿠키**

```java
import jakarta.servlet.http.Cookie;
    
    
    private void cookie(HttpServletResponse response) {
//        Set-Cookie: myCookie=good; Max-Age=600;
//        response.setHeader("Set-Cookie", "myCookie=good; Max-Age=600");
        Cookie cookie = new Cookie("myCookie", "good");
        cookie.setMaxAge(600); //600초
        response.addCookie(cookie);
    }
```

![image.png](attachment:8045ece5-bf2e-4a8a-bc30-73f7450b80b1:image.png)

**redirect**

```java
    private void redirect(HttpServletResponse response) throws IOException {
        //Status Code 302
        //Location: /basic/hello-form.html
//        response.setStatus(HttpServletResponse.SC_FOUND); //302
//        response.setHeader("Location", "/basic/hello-form.html");
        response.sendRedirect("/basic/hello-form.html");
    }
```

Status: 302, Location : url 면 url로 리다이렉트

## HTTP 응답 데이터

### 단순 텍스트 응답

`writer.println("ok");` - 앞에서 살펴봄 (ResponseHeaderServlet 참고)

### HTML 응답

```java
@WebServlet(name = "responseHtmlServlet", urlPatterns = "/response-html")
public class ResponseHtmlServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/html");
        response.setCharacterEncoding("utf-8");

        PrintWriter writer = response.getWriter();
        writer.println("<html>");
        writer.println("<body>");
        writer.println(" <div>안녕?</div>");
        writer.println("</body>");
        writer.println("</html>");
    }
}
```

Content-Type: text/html;charset=utf-8 부분 확인

![image.png](attachment:c6fb484f-2c08-4118-8883-943e03a54174:image.png)

### API JSON

```java
@WebServlet(name = "responseJsonServlet", urlPatterns = "/response-json")
public class ResponseJsonServlet extends HttpServlet {

    private ObjectMapper objectMapper = new ObjectMapper();

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("application/json");
        response.setCharacterEncoding("utf-8");

        HelloData helloData = new HelloData();
        helloData.setUsername("kim");
        helloData.setAge(20);

        // {"username":"kim", "age":20}
        String result = objectMapper.writeValueAsString(helloData);
        response.getWriter().write(result);
    }
}
```

Content-Type: application/json;charset=utf-8

![image.png](attachment:fd2e115b-35d9-4f75-b160-add4311b0bb3:image.png)

- 여기서 `application/json` 로만 나오게 하려면 response.getWriter() 대신 response.getOutputStream() 쓰면 된다.

### 회원 관리 웹 애플리케이션 만들기 - 서블릿, JSP, MVC 패턴

# 회원 관리 웹 애플리케이션 만들기

## 회원 관리 웹 애플리케이션 요구사항

회원 정보

이름: username

나이: age

기능 요구사항

- 회원 저장
- 회원 조회

member 도메인 모델

- 비즈니스 로직을 포함한 핵심 객체를 정의
- 서블릿에서는 기본 생성자가 필요하다.

```java
@Getter @Setter
public class Member {
    private Long id;
    private String username;
    private int age;

    // 기본 생성자
    public Member() {

    }

    public Member(String username, int age) {
        this.username = username;
        this.age = age;
    }
}
```

회원 저장소

- 싱글톤 패턴 적용 (private 처리)
- new MemberRepository()  불가
    - MemberRepository.getInstance() 로만 받아올 수 있음.

```java
public class MemberRepository {

    private static Map<Long, Member> store = new HashMap<>();
    private static long sequence = 0L;

    private static final MemberRepository instance = new MemberRepository();

    public static MemberRepository getInstance() {
        return instance;
    }

    private MemberRepository() {

    }

    public Member save(Member member) {
        member.setId(++sequence);
        store.put(member.getId(), member);
        return member;
    }

    public Member findById(Long id) {
        return store.get(id);
    }

    public List<Member> findAll() {
        // store 자체의 값을 보호하기 위해 새로운 ArrayList를 만들어서 보여주는 것
        return new ArrayList<>(store.values());
    }

    // 테스트 용 스토어 값 날리기
    public void clearStore() {
        store.clear();
    }
}
```

`테스트 코드`

```java
class MemberRepositoryTest {
    MemberRepository memberRepository = MemberRepository.getInstance();

    @AfterEach
    void afterEach() {
        memberRepository.clearStore();
    }

    @Test
    void save() {
        Member member = new Member("hello", 20);

        Member savedMember = memberRepository.save(member);
        Member findMember = memberRepository.findById(savedMember.getId());
        assertThat(findMember).isEqualTo(savedMember);
    }

    @Test
    void findAll() {
        Member member1 = new Member("member1", 20);
        Member member2 = new Member("member2", 30);

        memberRepository.save(member1);
        memberRepository.save(member2);

        List<Member> result = memberRepository.findAll();

        assertThat(result.size()).isEqualTo(2);
        assertThat(result).contains(member1, member2);
    }
}
```

## 서블릿

```java
@WebServlet(name = "memberFormServlet", urlPatterns = "/servlet/members/new-form")
public class MemberFormServlet extends HttpServlet {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        response.setContentType("text/html");
        response.setCharacterEncoding("utf-8");

        PrintWriter w = response.getWriter();
        w.write("<!DOCTYPE html>\n" +
                "<html>\n" +
                "<head>\n" +
                "    <meta charset=\"UTF-8\">\n" +
                "    <title>Title</title>\n" +
                "</head>\n" +
                "<body>\n" +
                "<form action=\"/servlet/members/save\" method=\"post\">\n" +
                "    username: <input type=\"text\" name=\"username\" />\n" +
                "    age:      <input type=\"text\" name=\"age\" />\n" +
                " <button type=\"submit\">전송</button>\n" + "</form>\n" +
                "</body>\n" +
                "</html>\n");
    }
}
```

아직 저장하는 부분을 만들지 않았지만 응답은 text/html utf-8 넣은 걸로 잘 들어간다.

![image.png](attachment:0fb26feb-378b-469e-a11b-4b82c9f86027:image.png)

```java
@WebServlet(name = "memberSaveServlet", urlPatterns = "/servlet/members/save")
public class MemberSaveServlet extends HttpServlet {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        System.out.println("MemberSaveServlet.service");
        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));

        Member member = new Member(username, age);
        memberRepository.save(member);

        response.setContentType("text/html");
        response.setCharacterEncoding("utf-8");

        PrintWriter w = response.getWriter();
        w.write("<html>\n" +
                "<head>\n" +
                " <meta charset=\"UTF-8\">\n" + "</head>\n" +
                "<body>\n" +
                "성공\n" +
                "<ul>\n" +
                "    <li>id="+member.getId()+"</li>\n" +
                "    <li>username="+member.getUsername()+"</li>\n" +
                " <li>age="+member.getAge()+"</li>\n" + "</ul>\n" +
                "<a href=\"/index.html\">메인</a>\n" + "</body>\n" +
                "</html>");
    }
}
```

![image.png](attachment:cff66552-eb95-4ea3-b06f-9d710f46e628:image.png)

저장된 모든 회원의 목록 조회

```java
@WebServlet(name = "memberListServlet", urlPatterns = "/servlet/members")
public class MemberListServlet extends HttpServlet {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        List<Member> members = memberRepository.findAll();

        response.setContentType("text/html");
        response.setCharacterEncoding("utf-8");

        PrintWriter w = response.getWriter();
        w.write("<html>");
        w.write("<head>");
        w.write("    <meta charset=\"UTF-8\">");
        w.write("    <title>Title</title>");
        w.write("</head>");
        w.write("<body>");
        w.write("<a href=\"/index.html\">메인</a>");
        w.write("<table>");
        w.write("    <thead>");
        w.write("    <th>id</th>");
        w.write("   <th>username</th>");
        w.write("   <th>age</th>");
        w.write("   </thead>");
        w.write("   <tbody>");

        for (Member member : members) {
            w.write("   <tr>");
            w.write("       <td>" + member.getId() + "</td>");
            w.write("      <td>" + member.getUsername() + "</td>");
            w.write("      <td>" + member.getAge() + "</td>");
            w.write("  </tr>");
        }
        w.write("   </tbody>");
        w.write("</table>");
        w.write("</body>");
        w.write("</html>");
    }
}
```

동적 html로 테이블로 리스트를 보여줌.

![image.png](attachment:5108ed7f-19be-4075-9124-16898f1305b0:image.png)

근데… 너무 힘들다 java에 html 쓰는 거…

<aside>
💡

**템플릿 엔진** 

- html에 java 코드를 넣어서 동적 html로 만들어 주는 것.
- JSP, Thymeleaf, Freemarker, Velocity 등
</aside>

## JSP

라이브러리 추가

```bash
	implementation 'org.apache.tomcat.embed:tomcat-embed-jasper'
	implementation 'jakarta.servlet:jakarta.servlet-api'
	implementation 'jakarta.servlet.jsp.jstl:jakarta.servlet.jsp.jstl-api'
	implementation 'org.glassfish.web:jakarta.servlet.jsp.jstl'
```

회원가입 부분

`main/webapp/jsp/members/new-form.jsp`

```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ page import="hello.servlet.domain.member.MemberRepository" %>
<%@ page import="hello.servlet.domain.member.Member" %>
<%
        //request, response 안 써놔도 사용 가능
        MemberRepository memberRepository = MemberRepository.getInstance();

        System.out.println("MemberSaveServlet.service");
        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));

        Member member = new Member(username, age);
        memberRepository.save(member);
%>

<html>
<head>
    <meta charset="UTF-8">
</head>
<body>
성공
<ul>
    <li>id=<%=member.getId()%></li>
    <li>username=<%=member.getUsername()%></li>
    <li>age=<%=member.getAge()%></li>
</ul>
<a href="/index.html">메인</a>
</body>
</html>
```

http://localhost:8080/jsp/members/new-form.jsp .jsp 까지도 써줘야 함.

`<% 여기는 java 코드 입력 %>`

`<%= 여기는 자바코드 출력 %>`

회원 조회 members.jsp

```html
<%@ page import="java.util.List" %>
 <%@ page import="hello.servlet.domain.member.MemberRepository" %>
 <%@ page import="hello.servlet.domain.member.Member" %>
 <%@ page contentType="text/html;charset=UTF-8" language="java" %>
 <%
     MemberRepository memberRepository = MemberRepository.getInstance();
     List<Member> members = memberRepository.findAll();
 %>
 <html>
 <head>
     <meta charset="UTF-8">
     <title>Title</title>
 </head>
<body>
<a href="/index.html">메인</a>
<table>
    <thead>
    <th>id</th>
    <th>username</th>
    <th>age</th>
    </thead>
    <tbody>
<%
    for (Member member : members) {
        out.write("     <tr>");
        out.write("         <td>" + member.getId() + "</td>");
        out.write("         <td>" + member.getUsername() + "</td>");
        out.write("         <td>" + member.getAge() + "</td>");
        out.write("     </tr>");
    }
%>
    </tbody>
</table>

</body>
</html>
```

서블릿 코드를 사용했고, 다른 점은 HTML을 중심으로 하고, 자바 코드를 부분부분 입력 한 것

### 서블릿과 JSP의 한계

- 서블릿 쓸 때 view(화면)을 위한 HTML 쓸 때 너무 힘들었다.
- JSP를 했는데 HTML 쓰는 것은 좋았으나 중간중간 동적으로 변경이 필요한 부분에만 자바 코드를 적용했다. 그렇지만… 여전히 불편하다. (나중에 코드 길어지면.. 유지보수 지옥 썰)

⇒ **MVC 패턴의 등장**

- 비즈니스 로직은 서블릿 처럼 다른곳에서 처리하고, JSP는 목적에 맞게 HTML로 화면(View)을 그리는 일에 집중할 수 있도록 MVC 패턴이 등장했다.

# MVC 패턴

## 개요

- MVC 이전
    - 비즈니스 로직과 뷰 렌더링까지 너무 많은 역할을 담당해서 유지보수가 어려웠다.
    - 변경 라이프 사이클이 다른데 한 코드에 있었다.
    - JSP는 뷰 템플릿은 렌더링 기능이 특화돼 있었다.
- **Model View Controller**
    - **컨트롤러**: HTTP 요청을 받아서 파라미터를 검증하고, **비즈니스 로직을 실행**한다. 그리고 뷰에 전달할 결과 데이터를 조회해서 모델에 담는다.
    - **모델**: 뷰에 출력할 데이터를 담아둔다. **뷰가 필요한 데이터를 모두 모델에 담아**서 전달해주는 덕분에 뷰는 비즈니스 로직이나 데이터 접근을 몰라도 되고, 화면을 렌더링 하는 일에 집중할 수 있다.
    - **뷰**: 모델에 담겨있는 데이터를 사용해서 **화면을 그리는 일에 집중**한다. 여기서는 HTML을 생성하는 부분을 말한다.

![image.png](attachment:44a7f6f6-d782-42be-abbb-54ab3d718b3e:image.png)

## 적용

`request.setAttribute()`, `request.getAttribute()`

### 회원 등록

- 컨트롤러 : 서블릿
- 뷰 : JSP
- 모델 : HttpServletRequest
    - request.setAttribute() - 데이터 보관
    - request.getAttribute() - 데이터 조회

**회원 등록 폼 - 컨트롤러**

```java
@WebServlet(name = "mvcMemberFormServlet", urlPatterns = "/servlet-mvc/members/new-form")
public class MvcMemberFormServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String viewPath = "/WEB-INF/views/new-form.jsp";
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);// 컨트롤러에서 뷰로 이동할 때 사용
        dispatcher.forward(request, response);
    }
}
```

- `dispatcher.forward()` : 다른 서블릿이나 JSP로 이동할 수 있는 기능 (서버 내부에서 다시 호출 발생)
- `WEB-INF` : 외부에서 JSP 를 직접 호출 하지 않고, 컨트롤러(여기서는 서블릿)를 통해서 부르고 싶어서 사용 (룰 같은 거라서 WEB-INF에 넣으면 직접 불러지지 않음)

<aside>
💡

**redirect vs forward**

- **redirect** : 클라이언트(웹 브라우저)에 응답이 나갔다가, 클라이언트가 redirect 경로로 다시 요청
    - 클라이언트가 인지할 수 있고, URL도 실제로 변경
- **forward :**  서버 내부에서 일어나는 호출로 클라이언트가 인지하지 못함.
</aside>

**회원 등록 폼 - 뷰**

`/webapp/WEB-INF/views/new-form.jsp`

```java
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
 <html>
 <head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<!-- 상대경로 사용, [현재 URL이 속한 계층 경로 + /save] -->
<form action="save" method="post">
    username: <input type="text" name="username" />
    age: <input type="text" name="age" />
<button type="submit">전송</button>
</form>
</body>
</html>
```

현재 계층 경로: `/servlet-mvc/members/`

결과: `/servlet-mvc/members/save`

절대 경로라면:`/setvlet-mvc/save`

- 절대 경로를 권장하지만 여기서는 재 사용하려고 상대경로를 사용했음.

### 회원 저장

**회원 저장 - 컨트롤러**

```java
@WebServlet(name = "mvcMemberSaveServlet", urlPatterns = "/servlet-mvc/members/save")
public class MvcMemberSaveServlet extends HttpServlet {

    MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String username = request.getParameter("username");
        int age = Integer.parseInt(request.getParameter("age"));

        Member member = new Member(username, age);
        memberRepository.save(member);

        // Model에 데이터 보관
        request.setAttribute("member", member);

        String viewPath = "/WEB-INF/views/save-result.jsp";
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response);
    }
}
```

**회원 저장 - 뷰**

```java
<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<html>
<head>
    <meta charset="UTF-8">
</head>
<body>
성공
<ul>
    <li>id=${member.id}</li>
    <li>username=${member.username}</li>
    <li>age=${member.age}</li>
</ul>
<a href="/index.html">메인</a>
</body>
</html>
```

- `<%=((Member)request.getAttribute("member")).getId()%>`  →  `${member.id}`
    - request의 attribute에 담긴 데이터를 편리하게 조회

![image.png](attachment:bb4715ac-6ea1-4648-953d-6f95eed45e45:image.png)

**회원 목록 조회 - 컨트롤러**

```java
@WebServlet(name = "mvcMemberListServlet", urlPatterns = "/servlet-mvc/members")
public class MvcMemberListServlet extends HttpServlet {

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

        List<Member> members = memberRepository.findAll();

        request.setAttribute("members", members);

        String viewPath = "/WEB-INF/views/members.jsp";
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response);
    }
}
```

**회원 목록 조회 - 뷰**

```java
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>

<html>
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<a href="/index.html">메인</a>
<table>
    <thead>
    <th>id</th>
    <th>username</th>
    <th>age</th>
    </thead>
    <tbody>
    <c:forEach var="item" items="${members}">
        <tr>
            <td>${item.id}</td>
            <td>${item.username}</td>
            <td>${item.age}</td>
        </tr>
    </c:forEach>
    </tbody>
</table>

</body>
</html>
```

### 한계

- 컨트롤러의 역할, 뷰의 렌더링 역할의 구분으로 아주 좋다.
- 근데… 코드 중복이 많다. 필요하지 않은 코드가 많다.

- **포워드 중복**
    
    ```java
    RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
    dispatcher.forward(request, response);
    ```
    

- **ViewPath 중복**
    
    ```java
     String viewPath = "/WEB-INF/views/new-form.jsp";
    ```
    

- **사용하지 않는 코드**
    
    ```java
    HttpServletRequest request, HttpServletResponse response
    ```
    

**→ 공통 처리의 어려움**

⇒ 컨트롤러 호출 전에 공통 기능을 처리 - **프론트 컨트롤러 패턴을 도입** - 스프링 MVC 핵심도 여기 있다.

## CS

### 메모리의 주소 공간

- `물리 주소`: 메모리 하드웨어가 사용하는 주소
- `논리 주소`: CPU와 실행 중인 프로그램 사용하는 주소
    - 실행 중인 프로그램 각각에게 부여된 0번지부터 시작되는 주소
- 메모리에 저장된 정보는 시시각각 변하기 때문에 CPU와 실행 중인 프로그램은 메모리 몇 번지에 뭐가 저장되어있는지 모른다.
- `메모리 관리 장치(MMU)` : 논리 주소와 물리 주소 간 변환 (CPU와 주소 버스 사이 위치)
- 예시 ) `베이스 레지스터` 45000이 저장 → CPU 논리 주소가 100 번지 라면 물리 주소는 45100번지로 변환

**메모리 보호 기법**

- `한계 레지스터`
    - 논리 주소 범위를 벗어나는 명령어 실행을 방지
    - 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호
    - 논리 주소의 최대 크기를 저장
    - CPU가 메모리에 접근하기 전, 접근하고자하는 논리 주소가 한계 레지스터보다 작은지 검사
        - CPU가 한계 레지스터보다 높은 논리 주소에 접근하려고 하면 **인터럽트(트랩)을 발생 → 중단**

### 캐시 메모리

**저장 장치 계층 구조 memory hierarchy**

1. CPU와 가까운 저장장치는 빠르고, 멀리 있는 저장장치는 느리다.
2. 속도가 빠른 저장장치는 용량이 작고, 가격이 비싸다.
- 레지스터, RAM(메모리), USB 메모리의 비교

| **레지스터** | 빠름 | 작음 | 비쌈 |
| --- | --- | --- | --- |
| **메모리** | **속도** | **용량** | **가격** |
| **보조기억장치** | 느림 | 큼 | 저렴함 |

`캐시 메모리`

- CPU가 메모리에 왔다 갔다 하는 시간이 오래 걸리므로, 메모리에서 CPU가 사용할 일부 데이터를 미리 캐시 메모리로 가지고 와서 활용함
- CPU와 메모리 사이에 있다.

| 레지스터 |
| --- |
| 캐시 메모리 |
| 메모리 |
| 보조기억장치 |
- CPU 코어와 가까운 순서 대로 L1 캐시, L2 캐시 (코어 내부), L3 캐시(코어 외부 - 여러 코어가 공유)
- 분리형 캐시 도 있다.
    - L1 - 명령어만 저장
    - L1D - 데이터만 저장

**참조 지역성 원리**

- 캐시 메모리는 CPU가 사용할 법한 대상을 예측하여 저장
- 실제로 예측이 맞아서 CPU가 사용할 경우 - `캐시 히트`
- 예측이 틀려서 직접 가져오는 경우 - `캐시 미스`

<aside>
💡

`캐시 적중률`

캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)

</aside>

- 대부분 컴퓨터의 캐시 적중률은 85~95%
- 어떻게 아는가? = `참조 지역성 원리`
    1. CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다. = `시간 지역성`
    2. CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다. = `공간 지역성`

## 스프링 입문 미션

## 1. 간단한 웹 페이지와 REST API 엔드포인트 구현

기본 웹 페이지를 설정하고 @RestController를 사용하여 간단한 REST API 엔드포인트를 구현합니다. 예를 들어, “Hello, World” 메시지를 반환하는 API를 만듭니다. 엔드포인트 실행 결과 스크린샷 및 코드를 결과물로 제출합니다.

### 기본 웹 페이지 설정

`main/resources/templates/index.html`

```html
<html>
<body>
    <h1>EXP [백엔드] 스프링 입문</h1>
</body>
</html>
```

![image.png](attachment:2fb1b661-f483-4f7b-a341-4f4b1f475cff:image.png)

### 간단한 REST API 엔드포인트를 구현

“Hello, World” 메시지를 반환하는 API

`main/java/grm/spring/basic/controller/RestPraticeController`

```java
package grm.spring.basic.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class RestPracticeController {

    @GetMapping("/hello")
    public String Hello() {
        return "Hello, World";
    }
}
```

![image.png](attachment:9a7fc056-fab2-4127-9e76-e5fbdef4c040:image.png)

<aside>
💡

**@Controller vs @RestController 차이**

1. **@Controller**
    - HTML 페이지를 반환할 때 사용 (Thymeleaf 같은 템플릿 엔진과 함께 사용)
    - @ResponseBody 없이 문자열을 반환하면 **뷰 이름**으로 처리됨
    - REST API 응답을 하려면 @ResponseBody를 붙여야 함
2. **@RestController**
    - JSON 데이터를 반환하는 컨트롤러 (REST API용)
    - 내부적으로 @Controller + @ResponseBody가 합쳐진 개념이라서, 따로 @ResponseBody를 안 붙여도 됨
    - 기본적으로 문자열을 반환하면 **그대로 응답 바디에 출력됨**
</aside>

## 2. MVC 패턴의 이해와 기본 구조 설계

스프링 부트에서의 MVC 패턴을 이해하고 Controller, Service, Repository 계층을 사용하여 간단한 구조를 설계합니다. 예를 들어, 가상의 **회원 정보를 처리**하는 구조를 구현해 봅니다. 기본 MVC 구조 파일 및 계층 설명을 PDF 문서로 만들어 결과물로 제출합니다.

src/main/java/grm/spring/basic/

- controller - 클라이언트 요청을 받아서 서비스를 호출하고 응답을 반환
    - MemberController.java - 회원 등록 API, 모든 회원 목록 조회 API 엔드포인트 구현
- service - 비즈니스 로직을 처리 데이터를 관리
    - MemberService.java - 회원 저장, 조회 기능
- repository - 데이터를 저장, 조회하는 역할(이후 DB 연동)
    - MemberRepository.java - 회원 정보 저장 클래스
- domain(model) - 데이터를 담는 객체
    - Member.java - id, username 등 필드 클래스

![image.png](attachment:9057b871-5aa2-4b7f-b6d1-4392380044df:image.png)

## 3. 의존성 주입(DI) 이해하기

스프링 부트의 의존성 주입 방식을 학습하고, @Autowired와 @Component 애노테이션을 사용하여 DI를 구현해 봅니다. 예를 들어, 의존성 주입을 활용해 **여러 서비스 간의 의존성을 설정**합니다. 의존성 주입 코드 및 스크린샷을 결과물로 제출합니다.

- 회원 가입시 콘솔 알림 기능 호출
    - MemberService가 NotificationService의 의존성 주입을 통해 사용

- **코드 구현**
    
    `service/MemberService.java`
    
    - 레포지토리 없이 List에 추가
    - 생성자 주입 - 테스트 코드에서 new로 객체 만들어서 주입할 예정
    
    ```java
    package grm.spring.basic.service;
    
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Component;
    
    import java.util.ArrayList;
    import java.util.List;
    
    @Component
    public class MemberService {
        private List<String> members = new ArrayList<>();
        private NotificationService notificationService;
    
        @Autowired
        public MemberService(NotificationService notificationService) {
            this.notificationService = notificationService;
        }
    
        public void save(String username) {
            members.add(username);
            notificationService.sendNotification(username);
        }
    
        public List<String> findAll() {
            return members;
        }
    }
    
    ```
    
    `service/NotificationService.java`
    
    - 콘솔에 프린트해서 알림
    
    ```java
    package grm.spring.basic.service;
    
    import org.springframework.stereotype.Component;
    
    @Component
    public class NotificationService {
        public void sendNotification(String username) {
            System.out.println(username + "님 회원가입 완료");
        }
    }
    ```
    

`test/java/…/service/MemberServiceTest`

```java
package grm.spring.basic.service;

import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;

import static org.junit.jupiter.api.Assertions.*;

class MemberServiceTest {

    MemberService memberService;

    @BeforeEach
    void setUp() {
        memberService = new MemberService(new NotificationService());
    }

    @Test
    public void testMemberJoin() {
        // Given
        String username = "kim";

        // When
        memberService.save(username);

        // Then
        Assertions.assertThat(memberService.findAll()).contains(username);
        System.out.println("테스트 완료");
    }
}
```

- **테스트 결과**
    
    ![image.png](attachment:c301844d-2229-42b4-a48e-20a8e5284069:image.png)
    