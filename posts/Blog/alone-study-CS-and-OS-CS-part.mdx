---
title: "[CS] 혼공컴운 - 컴퓨터 구조 파트"
description: "혼공컴운 책 읽고 정리 - 컴퓨터 구조"
date: "2025.01.06 ~ 2025.02.14"
filter: ["CS"]
---

## 컴퓨터 구조 이해하기

### 컴퓨터 구조는 왜 배우나요?

<aside>
  💻 
	- 문제해결 능력 향상 
	- 문법을 넘어 성능, 용량, 비용을 고려하며 개발할 수
  있다.
</aside>

**문제해결**
- 컴퓨터라는 기계에 코드를 ‘입력’만 할 수 있을 수는 없다.
- 컴퓨터 내부를 분석하며 문제 상황 진단과 더 좋은 해결책을 고민하기 위해

**성능, 용량, 비용**
- 서버 컴퓨터를 고를 때 성능, 용량, 비용을 고려해야 한다.
- 물론 클라우드 서비스도 어떤 CPU를 사용할지, 어떤 메로리를 사용할지 판단 해야 함.
- 개발한 프로그램이 어떤 환경에서 어떻게 작동 하는지 잘 이해하고 있어야 함.
- 최적의 컴퓨터 환경을 판단할 수 있어야 함.

### 컴퓨터 구조

**컴퓨터가 이해하는 정보**
- 데이터 : 컴퓨터가 이해하는 숫자, 문자, 동영상 등 정적인 정보
- 명령어 : 데이터를 움직이고 컴퓨터를 작동시키는 정보

**컴퓨터 부품**
- CPU
  - ALU : 계산
  - 레지스터 : 임시 저장장치
  - 제어장치 : 메모리 읽기, 메모리 쓰기, 명령어 해석
- 메모리(RAM, ROM)
  - 현재 실행되는 프로그램의 명령어와 데이터를 저장
  - 값의 위치는 주소로 저장
- 보조기억장치
  - 하드, SSD, USB 등
- 입출력장치
  - 모니터, 키보드, 마우스

→ 메인보드에 연결됨 - 버스라는 통로가 있고 부품을 연결하는 통로는 시스템 버스

- 시스템 버스
  - 주소 버스
  - 데이터 버스
  - 제어 버스

## 데이터

2025년 1월 8일

### 0과 1로 숫자 표현

정보 단위

`비트` 0과 1을 표현하는 가장 작은 단위

1 비트 - 2가지

2비트 - 4가지 … n 비트는 2^n 가지의 정보 표현이 가능하다.

**`이진법`**
이진수의 음수 2의 보수

- 어떤 수를 그보다 큰 2^n에서 뺀 값
- 쉽게 하자면, 모든 0과 1을 뒤집어서 1을 더한 값

`플래그`

- 수가 양수인지 음수인지 구분

**`십육진법`**
- 숫자의 길이가 너무 길어져서 사용
- 이진법으로 변환이 쉬움

2^4 = 16이므로 십육진수 → 이진수 로 표현하려면 4비트가 필요함.

예) 1A2B(16) = 0001101000101011(2)

이진수 → 십육진수 ⇒ 4개씩 끊어서 바꿔주면 된다.

예) 11010101(2) = D5(16)

2025년 1월 9일

### 0과 1로 문자 표현

- 문자 set : 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
- 문자 인코딩: 문자를 0, 1로 변환, 인코딩 후 0, 1로 이루어진 결과값이 `문자코드`가 된다.
- 디코딩: 문자 코드를 사람이 이해할 수 있는 문자로 변환

`아스키 코드`

- 초기 문자 집합 중 하나
- 영어 알파벳, 아라비아 숫자, 일부 특수문자 포함
- 각 7비트로 표현, 2^7 = 128개 문자 표현 가능
  - 8비트 인데 1비트는 parity bit로 오류 검출용
- 표현 가능한 문자 수가 부족하다는 단점

한글 인코딩

- 완성형 인코딩
- 조합형 인코딩

`EUC-KR`

- 대표적인 완성형 인코딩 방식
- 한글 한글자는 16비트 - 16진수로 표현
- 2350개 정도 가능 - 아직 부족함

**유니코드와 UTF-8**

`유니코드`

- 모든 언어를 아우르는 문자 집합
- 통일된 표준 인코딩 방식

→ 유니코드는 글자에 부여된 값 자체를 인코딩 값으로 하지 않음.

- 인코딩 방법으로 UTF-8, UTF-16, UTF-32 등이 있다.

`UTF-8`

16진법으로

0000~007F - 1 바이트로 표현

0080~07FF - 2 바이트로 표현

0800~FFFF - 3 바이트로 표현

10000~10FFFF - 4 바이트로 표현

## 명령어

### 소스 코드

개발자 - 소스코드 -변환→ 명령어 - 컴퓨터

`고급언어` : 사람을 위한 언어 - 대부분의 프로그래밍 언어

`저급언어` : 컴퓨터가 직접 이해하고 실행하는 언어 = 명령어

- 기계어 - 0, 1로 이루어지거나, 십육진수로 표현됨
- 어셈블리어 - 기계어를 사람이 읽기 편한 형태로 번역한 언어
  - 안쓸 것 같지만.. 임베디드, 게임, 정보보안 등 많이 사용함

`컴파일 언어` : 소스코드 전체가 저급언어로 변환되어 실행 - C

- 소스 코드 전체가 저급 언어로 변환되는 과정 = `컴파일`
- 소스코드(고급언어) —컴파일—> `목적코드`(저급언어)

`인터프리터 언어` : 코드가 한 줄씩 실행되는 언어 - Python

- 컴파일언어와 다르게 오류가 있기 전까지 실행
- 대신 컴파일 언어보다 느리다

목적파일 —링킹—> 실행파일 : 여기 조금 이해 못함..

### 명령어의 구조

| **연산 코드** | **오퍼랜드** |
| ------------- | ------------ |

`오퍼랜드` : 연산에 사용할 데이터 - 피연산자

- 연산에 사용할 데이터, 데이터가 저장된 위치
- 많은 경우 데이터가 저장된 위치, 메모리 주소나 레지스터 이름이 담김
- 오퍼랜드 필드 = `주소 필드`
- 한 명령어 안에 없을 수도, 1개만 있을 수도, 2,3개가 있을 수도 있다

`0- 주소 명령어`

| **연산 코드** |
| :----------: |

`1- 주소 명령어`

| **연산 코드** | **오퍼랜드** |
| ------------- | ------------ |

`2- 주소 명령어`

| **연산 코드** | **오퍼랜드** | **오퍼랜드** |
| ------------- | ------------ | ------------ |

`연산코드` : 명령어가 수행할 연산 - 연산자

1. 데이터 전송
   - MOVE, STORE, LOAD(FETCH), PUSH, POP
2. 산술/논리 연산
   - ADD/SUBTRACK/MULTIPLY/DIVIDE, INCREMENT/DEVREMENT, AND/OR/NOT, COMPARE
3. 제어 흐름 변경
   - JUMP, CONDITIONAL JUMP, HALT, CALL, RETURN
4. 입출력 제어
   - READ(INPUT), WRITE(OUTPUT), START IO, TEST IO

- 명령어에 데이터 대신 주소를 담는 이유는 명령어 길이 때문이다. 오퍼 랜드의 길이는 (명렁어 n 비트) - (연산 코드 m 비트)가 된다. 2, 3-주소 명령어가 더 작아진다.
- 예) 한 주소에 16비트를 저장하는 메모리가 있다면 여기 데이터를 저장하고, 오퍼랜드 필드(4비트) 에 메모리 주소 명시로 표현하면 2^16가지의 정보를 담을 수 있다.

`유효주소`

- 연산의 대상이 되는 데이터가 저장된 위치

`주소 지정 방식` - 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법

- `즉시 주소 지정 방식` - **데이터**를 오퍼랜드 필드에 직접 명시
- `직접 주소 지정 방식` - 오퍼랜드 필드에 **유효 주소**를 직접적으로 명시
- `간접 주소 지정 방식` - **유효 주소의 주소**를 오퍼랜드 필드에 명시
- `레지스터 주소 지정 방식` - 연산에 사용할 데이터를 저장한 **레지스터**를 오퍼랜드 필드에 직접 명시 / 일반적으로 메모리에 접근하는 것보다 CPU내부 레지스터에 접근하는 것이 더 빠르다.
- `레지스터 간접 주소 지정 방식` - 연산에 사용할 데이터를 메모리에 저장하고, **유효주소를 저장한 레지스터**를 오퍼랜드 필드에 명시 / 간접 주소 지정방식보다 빠르다.

## CPU의 작동원리

### ALU

- 계산을 하는 부품

**받아들이는 정보**

- 레지스터를 통해 `피연산자`를 받고, 제어장치로부터 수행할 연산을 알려주는 `제어 신호`를 받는다.
- 산술연산, 논리 연산 등 다양한 연산 수행

**내보내는 정보**

- 수행한 `결과` - 특정 숫자, 문자, 메모리 주소
  - 바로 메모리로 가는 게 아니라 레지스터에 저장
    - CPU가 메모리에 접근하는 속도 < 레지스터에 접근하는 속도 기 때문에 CPU가 메모리에 자주 접근하지 않도록(실행 속도를 늦추는 것) 레지스터에 저장하는 것
- 계산 결과와 더불어 `플래그`를 내보냄
  - 추가적인 상태 정보 (예, 계산한 결과는 음수, 오버플로우 등)
    | (대표적인) 플래그 종류 | 예시 |
    | ---------------------- | --------------------------------------------- |
    | **부호 플래그** | 1은 음수, 0은 양수 |
    | **제로 플래그** | 1은 0, 0은 0이 아닌 값 |
    | **캐리 플래그** | 1은 올림수 또는 빌림수 발생, 0은 발생 x |
    | **오버플로우** | 1은 오버플로우 발생, 0은 발생 x |
    | **인터럽트 플래그** | 1은 인터럽트 가능, 0은 불가능 |
    | **슈퍼바이저 플래그** | 1은 커널모드 실행 중, 0은 사용자 모드 실행 중 | \*오버플로우: 연산 결과가 연산 결과를 담을 레지스터보다 큰 상황
  - 플래그 레지스터에 따로 저장
  - 예시) 플래그 레지스터
    | 부호 | 제로 | 캐리 | 오버플로우 | 인터럽트 | 슈퍼바이저 |
    | ---- | ---- | ---- | ---------- | -------- | ---------- |
    | 1 | 0 | 0 | 0 | 0 | 0 |

### 제어 장치

- 제어 신호를 내보내고, 명령어를 해석하는 부품

**받아들이는 정보**

1. `클럭 신호`

   `클럭`: 부품이 움직이는 시간 단위(주기적으로 똑-딱-똑-딱) 디지털 신호..라고 생각하면 되려나?

2. 해석해야 할 `명령어`

   명령어 레지스터에 저장

3. 플래그 레지스터 속 `플래그 값`
4. 시스템 버스 중 제어 버스로 전달된 `제어 신호`

**내보내는 정보**

- CPU 외부로 내보내는 정보 (제어 버스로 제어 신호를 내보낸다는 것)
  - 메모리에 전달하는 제어 신호 - 메모리에 새로운 값을 쓰고 싶을 때
  - 입출력 장치에 전달하는 제어 신호 - 입출력 장치에 새로운 값을 쓰고 싶을 때
- CPU 내부로 내보내는 정보
  - ALU에 전달하는 제어 신호 - 수행할 연산 지시
  - 레지스터에 전달하는 제어 신호 - 레지스터 간 데이터 이동, 레지스터에 저장된 명령어 해석

### 레지스터

1. `프로그램 카운터` (명령어 포인터)
   - 메모리에서 읽어올 명령어의 주소를 저장
2. `메모리 주소 레지스터`
   - 메모리 주소를 저장
3. `메모리 버퍼 레지스터` (메모리 데이터 레지스터)
   - 메모리와 주고 받을 값(데이터, 명령어)를 저장
4. `명령어 레지스터`
   - 방금 메모리에서 읽어온 명령어를 저장
5. 범용 레지스터
   - 데이터와 주소 모두 저장 가능
   - 여러개가 있음
6. 플래그 레지스터
   - ALU 연산 결과에 따른 플래그를 저장

주소 지정 방식

1. 스택 주소 지정 방식
   - 스택과 스택 포인터(스택의 꼭대기를 가르키는 레지스터 = 마지막에 저장한 값)를 이용한 주소 지정 방식
2. 변위 주소 지정 방식
   1. 상대 주소 지정 방식
      - 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
      - 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용
   2. 베이스 레지스터 주소지정 방식
      - 오퍼랜드(사이 거리)와 베이스 레지스터(기준 주소)의 값을 더하여 유효 주소를 얻는 방식

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6ff381ac-b14b-424e-b245-44ff046856c4/ad3c2eb1-5bab-4fda-a378-9d1e670860c0/image.png)

### 명령어 사이클

- 프로그램 속 각각의 명령어들이 실행되는 일정한 반복 주기

1. `인출 사이클` - 메모리에 있는 명령어를 CPU로 가지고 오는 단계
2. `실행 사이클` - CPU로 가져온 명령어를 실행하는 단계
   - 제어장치가 명령어 레지스터에 담긴 값을 해석, 제어 신호를 발생시키는 단계

인출 ↔ 실행

1. `간접 사이클` - 어떤 명령어의 경우 간접 주소를 가져오기 위해 메모리에 한번 더 접근함.

### 인터럽트

- CPU가 수행 중인 작업을 방해하는 신호
- 동기 인터럽트 = 예외(`Exception`)
  - CPU에 의해 발생하는 인터럽트
  - 프로그래밍상의 오류와 같은 예외적인 상항에 마주쳤을 때
  - `폴트` : 예외 처리 직후 예외가 발생한 명령어부터 실행 재개
  - `트랩` : 예외 처리 직후 예외가 발생한 명령어의 다음 명령어 부터 실행 재개
  - `중단abort` : CPU가 실행 중인 프로그램을 강제로 중단
  - `소프트웨어 인터럽트` : 시스템 호출이 발생 했을 때
- 비동기 인터럽트 = `하드웨어 인터럽트`
  - 주로 입출력 장치에 의해 발생하는 인터럽트
  - 알림 역할
  - 키보드, 마우스, 프린터 등등
  - 처리 순서
    1. 입출력장치가 CPU에 `인터럽트 요청 신호`를 보냄
    2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인
    3. CPU는 인터럽트 요청을 확인하고 `인터럽트 플래그`를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
    4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업
    5. CPU는 `인터럽트 벡터`를 참조하여 `인터럽트 서비스 루틴`을 실행
    6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해둔 작업을 복구해 실행 재개
  - `인터럽트 요청 신호` : “끼어들어도 될까요?”
  - `인터럽트 플래그` : 플래그 레지스터가 가능으로 되어 있어야 한다.
    - 불가능으로 설정되어 있어도 `무시할 수 없는 하드웨어 인터럽트`가 우선순위가 높다. ⇒ 하드웨어 고장 같은 거
  - `인터럽트 서비스 루틴` : 인터럽트를 처리하기 위한 프로그램 = `인터럽트 핸들러`
  - `인터럽트 벡터` : 인터럽트 서비스 루틴을 식별하기 위한 정보, 서비스 루틴의 시작 주소를 알 수 있음.
    - 명령어와 데이터로 이루어져있음.
    - 레지스터를 사용하며 실행

## CPU 성능 향상 기법

### 빠른 CPU를 위한 설계 기법

`클럭` : 부품들은 클럭 신호에 따라 움직인다.

- 클럭 속도가 높을 수록 CPU 성능이 좋다. CPU 속도 단위 = 클럭 속도
- 무작정 높다고 좋지는 않다. 왜? 발열 문제!!

→ `코어`와 `스레드` 수를 늘리는 방법

`멀티코어` : CPU하나에 코어(CPU)가 여러개 있다.

- 연산속도가 코어 수에 비례하여 증가하지는 않음.(팀플을 생각해보자..)
- 코어마다 처리할 명령어를 얼마나 적절하게 분배하느냐가 연산 속도에 큰 영향을 준다.

`스레드` : 실행 흐름의 단위(사전적)

- `하드웨어적 스레드` : 하나의 코어가 동시에 처리하는 명령어 단위 (예, 8코어 16스레드 cpu ⇒ 코어 하나당 2 개의 하드웨어 스레드를 처리)
- `소프트웨어적 스레드` : 하나의 프로그램에서 독립적으로 실행되는 단위
  1. 사용자로 부터 입력받은 내용을 화면에 보여 주는 기능
  2. 사용자가 입력한 내용이 맞춤법에 맞는지 검사하는 기능
  3. 사용자가 입력한 내용을 수시로 저장하는 기능
  - 을 각각 스레드로 만들어서 동시에 실행할 수 있다.

`멀티스레드 프로세서`

- 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
- 레지스터 세트가 코어 당 2개씩 있다면 2스레드가 되는 것 처럼.. 그림에 나와있음.

### 명령어 병렬 처리 기법

CPU가 놀지 않고 시간을 알뜰하게 쓰면서 작동하게 만드는 것

`명령어 파이프라인`

명령어 처리 과정

- 명령어 인출 → 명령어 해석 → 실행 → 결과 저장
- 같은 단계가 겹치지 않는다면 CPU는 각 단계를 동시에 실행할 수 있다.
- 한 명령어가 끝나고 다음 명령어가 실행되는 것보다 훨씬 빠름
- `파이프라인 위험` : 성능 향상에 실패하는 경우
  - 데이터 위험 : 데이터 의존성에 의해 발생, 이전 명령어를 끝까지 실행해야 실행할 수 있는 경우 → 파이프라인이 제대로 작동하지 않음
  - 제어 위험 : 프로그램 카운터의 갑작스러운 변화로 발생(번지수 분기)
  - 구조적 위험 : 서로 다른 명령어가 ALU, 레지스터 등 CPU 부품을 사용하려고 할 때 발생

`슈퍼 스칼라`

- 여러개의 명령어 파이프라인이 있는 것
- 파이프라인 위험이 더 까다롭게 됨

`비순차적 명령어 처리`

- 대부분 CPU가 차용
- 합법적 새치기 기법
- 명령어들이 어떤 명령어와 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는 명령어는 어떤게 있는지 판단해야 한다.

### CISC 와 RISC

명령어 집합 = `명령어 집합 구조(ISA)` - CPU가 이해할 수 있는 명령어들의 모음

- CPU 마다 이해하고 실행할 수 있는 명령어가 다르니, 같은 명령어를 각자 컴파일하면 나오는 어셈블리어도 달라진다.
- ISA가 다르다는 것은 명령어 뿐 아니라 그 명령어를 처리하는 CPU 하드웨어의 설계에도 큰 영향을 미친다.

`CISC`(Complex Instruction Set Computer)

- 복잡하고 다양한 수의 `가변 길이 명령어` 집합을 활용
- 프로그램을 실행하는 명령어 수가 적다 = 컴파일된 프로그램의 크기가 작다
  - 메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높았음.
- 다양한 주소 지정 방식
- 규격화되지 않은 명령어(여러 클럭에 걸쳐 명령어 수행)라 파이프라이닝이 어려워짐. → 성능 측면 문제
- 어려운 명령어를 수행할 수 있지만, 현실은 쓰는 명령어를 많이 쓰는 걸

`RISC`(Reduced Instruction Set Computer)

- 짧고 규격화된 `고정 길이 명령어`를 활용
- 프로그램을 이루는 명령어 수가 많음
- 원활한 파이프라이닝(1클럭 내외로 명령어 수행)

## 메모리와 캐시 메모리

### RAM의 특징과 종류

**RAM의 특징**

- 실행할 프로그램의 명령어와 데이터가 저장
- 전원을 끄면 저장된 내용이 사라지는 `휘발성 저장장치`
  - `비휘발성 저장장치` : 하드디스크, SSD, CD-ROM, USB 등 보조기억장치들
- CPU는 보조기억장치에 직접 접근을 못함 ⇒ 실행하려면 RAM으로 복사해서 저장한 뒤 실행

**RAM의 용량과 성능**

- RAM 용량이 커지만 프로그램 실행 속도가 어느 정도 증가하지만 속도가 비례해서 증가하지는 않음

**RAM의 종류**

- `DRAM`
  - 시간이 지나면 저장된 데이터가 점차 사라짐.
  - 일정주기로 데이터를 재활성화(다시 저장)해야함.
  - 하지만 쓰는 이유? 소비 전력 낮고, 싸고, 집적도 높음.

- `SRAM`
  - 시간이 지나도 데이터가 사라지지 않음
  - 속도가 DRAM보다 빠름
  - 집적도가 낮고, 소비 전력도 크고, 비쌈
  - 대용량일 필요 없지만 속도가 빨라야 하는 `캐시 메모리` 같은 거에 사용

- `SDRAM` - SRAM과 관련 없음
  - 클럭 신호와 동기화된, 발전된 형태의 DRAM
	
- `DDR SDRAM` - 최근 RAM
  - 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
  - 너비가 2배, 한 클럭당 두번씩 CPU와 데이터를 주고 받음
  - DDR2, DDR3 등 있음

![Image](https://blog.kakaocdn.net/dn/dCp9Uq/btqwhTDhICS/2lHkVdCkdLGCqF0HudziT0/img.png)



### 메모리의 주소 공간

- `물리 주소`: 메모리 하드웨어가 사용하는 주소
- `논리 주소`: CPU와 실행 중인 프로그램 사용하는 주소
    - 실행 중인 프로그램 각각에게 부여된 0번지부터 시작되는 주소
- 메모리에 저장된 정보는 시시각각 변하기 때문에 CPU와 실행 중인 프로그램은 메모리 몇 번지에 뭐가 저장되어있는지 모른다.
- `메모리 관리 장치(MMU)` : 논리 주소와 물리 주소 간 변환 (CPU와 주소 버스 사이 위치)
- 예시 ) `베이스 레지스터` 45000이 저장 → CPU 논리 주소가 100 번지 라면 물리 주소는 45100번지로 변환

**메모리 보호 기법**

- `한계 레지스터`
    - 논리 주소 범위를 벗어나는 명령어 실행을 방지
    - 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호
    - 논리 주소의 최대 크기를 저장
    - CPU가 메모리에 접근하기 전, 접근하고자하는 논리 주소가 한계 레지스터보다 작은지 검사
        - CPU가 한계 레지스터보다 높은 논리 주소에 접근하려고 하면 **인터럽트(트랩)을 발생 → 중단**

### 캐시 메모리

**저장 장치 계층 구조 memory hierarchy**

1. CPU와 가까운 저장장치는 빠르고, 멀리 있는 저장장치는 느리다.
2. 속도가 빠른 저장장치는 용량이 작고, 가격이 비싸다.
- 레지스터, RAM(메모리), USB 메모리의 비교

| **레지스터** | 빠름 | 작음 | 비쌈 |
| --- | --- | --- | --- |
| **메모리** | **속도** | **용량** | **가격** |
| **보조기억장치** | 느림 | 큼 | 저렴함 |

`캐시 메모리`

- CPU가 메모리에 왔다 갔다 하는 시간이 오래 걸리므로, 메모리에서 CPU가 사용할 일부 데이터를 미리 캐시 메모리로 가지고 와서 활용함
- CPU와 메모리 사이에 있다.

| 레지스터 |
| --- |
| 캐시 메모리 |
| 메모리 |
| 보조기억장치 |
- CPU 코어와 가까운 순서 대로 L1 캐시, L2 캐시 (코어 내부), L3 캐시(코어 외부 - 여러 코어가 공유)
- 분리형 캐시 도 있다.
    - L1 - 명령어만 저장
    - L1D - 데이터만 저장

**참조 지역성 원리**

- 캐시 메모리는 CPU가 사용할 법한 대상을 예측하여 저장
- 실제로 예측이 맞아서 CPU가 사용할 경우 - `캐시 히트`
- 예측이 틀려서 직접 가져오는 경우 - `캐시 미스`

<aside>
💡 `캐시 적중률`

캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)

</aside>

- 대부분 컴퓨터의 캐시 적중률은 85~95%
- 어떻게 아는가? = `참조 지역성 원리`
    1. CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다. = `시간 지역성`
    2. CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다. = `공간 지역성`

## 보조기억장치

### 하드디스크

- 자기적인 방식으로 데이터를 저장

![Image](https://github.com/user-attachments/assets/57b9d9e6-12df-4f87-be91-5e0691b0f4d8)

- `플래터` - N극 S극, 0과 1의 역할 수행
- 플래터를 돌리는 `스핀들`의 속도 단위는 RPM
- `헤드`로 데이터를 읽고 씀
- 헤드를 `디스크 암`으로 움직임
- `트랙`(원형), `섹터`(조각) 단위로 데이터 저장
- 여러 겹의 플래터 상 같은 트랙이 위치한 곳을 모아 연결한 논리적 단위는 `실린더`
- 연속된 정보는 한 실린더에 기록
- 하드 디스크가 저장된 데이터에 접근하는 시간
    - 탐색시간 - 데이터가 저장된 트랙까지 헤드를 이동시키는 시간
    - 회전 지연 - 헤드가 있는 곳으로 플래터를 회전시키는 시간
    - 전송 시간 - 하드 디스크와 컴퓨터 간에 데이터를 전송하는 시간

### 플래시 메모리

- 데이터를 저장하는 가장 작은 단위 `셀`
    - SLC - 1셀에 1비트
        - 빠른 입출력 가능 (1, 0 밖에 없어서)
        - 수명이 길다. 수만~ 수십만법 데이터를 쓰고 지우고 반복
        - 가격이 높다
    - MLC - 1셀에 2비트
        - SLC 보다 대용량화에 유리
    - TLC - 1셀에 3비트
        - 저가의 대용량 저장장치를 원한다면
- 셀들이 모여 만들어진 `페이지`
    - 3가지 상태가 가능 `Free`, `Valid`, `Invalid`
- 페이지가 모여 만들어진 `블록`
- `플레인` < `다이`
- 덮어쓰기가 불가능
- 페이지 단위로 **읽기, 쓰기**가 가능
- 블록단위로 **삭제**할 수 있음 - `가비지 컬렉션`
    - valid 페이지만 따로 모은 데이터를 새로운 블록에 옮기고 기존 블록은 삭제

### RAID의 정의와 종류

**`RAID` (Redundant Array of Independent Disks)** 

- 보조기억장치는 수명이 있다.
- 하드 디스크와 SSD를 사용하는 기술
- 데이터의 안전성 혹은 높은 성능을 위해 여러 개의 물리적 보조기억장치를 하나의 논리적 보조기억장치처럼 사용하는 기술
- `RAID 레벨` - RAID 구성 방법
- `RAID 0`
    - `stripe` - 각 하드 디스크를 번갈아 가면서 데이터를 저장(줄무늬)
    - 한 하드 디스크에서 문제가 생기면 모든 하드 디스크의 정보를 읽는데 문제가 생김
- `RAID 1`
    - `mirroring` - 스트라이핑이 사용되지만 복사본을 만들어서 백업이 가능하도록 함.
    - 원본, 복사본이 필요하므로 속도는 RAID0보다 느림
- `RAID 4`
    - 완벽한 복사본 대신 오류를 검출하고 복구하기 위한 정보를 저장
    - 그 정보를 `패리티 비트` 라고 함.
    - 원래는 오류 검출용 정보지만, RAID에서는 오류 복구도 가능
    - 새로운 데이터가 저장될 때마다 패리티를 저장하는 디스크도 데이터를 쓰게 되어 패리티 저장 장치에 병목 현상이 발생
- `RAID 5`
    - 패리티 정보를 `분산하여 저장`하는 방식으로 병목현상을 해소
- `RAID 6`
    - RAID 5와 기본적으로 같지만 `서로 다른 두 개의 패리티`를 두는 방식
    - 쓰기 속도는 느리지만 데이터를 더욱 안전하게 보관하고 싶을 때 사용하는 방식


## 입출력 장치

### 장치 컨트롤러

- 입출력 제어기, 입출력 모듈 등으로 부른다.
- CPU와 입출력장치 간의 통신 중개
- 오류 검출
- 데이터 버퍼링
    - 전송률이 높은 장치와 낮은 장치 사이에 주고받는 데이터를 `버퍼` 라는 입시 저장 공간에 저장해서 전송률을 비슷하게 맞추는 방법
    - 버퍼에 데이터를 많이 받아놨다가 조금씩 내보내거나, 모아뒀다가 한번에 내보냄
- 내부에는..
    - `데이터 레지스터` - CPU와 입출력장치 사이에 주고받을 데이터가 담기는 레지스터
    - `상태 레지스터` - 입출력 작업 준비되었는지, 작업 완료 되었는지, 오류는 없는지 상태 정보 저장
    - `제어 레지스터` - 입출력장치가 수행할 내용에 대한 제어 정보와 명령을 저장

### 장치 드라이버

- 장치 컨트롤러의 동작을 감지하고 제어, 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게 하는 프로그램

### 프로그램 입출력

- 기본적으로 프로그램 속 명령어로 입출력장치를 제어하는 방법
- `메모리 맵 입출력`
    - 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법
    - 메모리 주소 공간이 축소됨
    - 메모리 주소와 장치 컨트롤러의 레지스터를 모두 메모리 주소 대하듯 한다.
- `고립형 입출력`
    - 메모리를 위한 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법
    - 메모리 주소 공간이 축소되지 않음
    - 입출력 전용 명령어를 사용

### 인터럽트 기반 입출력

- CPU가 장치 컨트롤러에 입출력 작업을 명령하고, 장치 컨트롤러가 입출력장치를 제어하며 입출력 하는 동안 CPU가 다른 일을 한다.
- 입출력 작업이 끝난 후 CPU에게 인터럽트 요청 신호를 보내면 CPU는 하던 일을 백업하고 인터럽트 서비스 루틴을 실행
- ↔  `풀링` - CPU가 입출력장치의 상태는 어떤지(상태 레지스터), 처리할 데이터가 있는지 주기적으로 확인하는 방식
- 인터럽트 비트를 비활성화해도 무시할 수 없는 인터럽트인, `NMI`(Non-Maskable Interrupt)가 발생하면 CPU는 우선순위가 높은 인터럽트부터 처리함
- `프로그래머블 인터럽트 컨트롤러` : 우선순위를 반영하여 다중 인터럽트를 처리할 때 쓰는 하드웨어
    - 우선순위 판별한 뒤 CPU에 지금 처리해야 할 하드웨어 인터럽트가 무엇인지 알려주는 장치
    - 각 핀마다 CPU에 하드웨어 인터럽트 요청을 보낼 수 있는 정해진 하드웨어가 연결되어 있음
        - 1번 핀 - 타이머 인터럽트 핀
        - 2번 핀 - 키보드 인터럽트 핀 등등
- **다중 인터럽트 처리 과정**
    1. PIC가 장치 컨트롤러에서 `인터럽트 요청 신호`를 받아 들임
    2. PIC가 우선순위 판단 후 CPU에 `인터럽트 요청 신호` 보내기
    3. CPU는 PIC의 `인터럽트 확인 신호`를 보냄
    4. PIC는 데이터 버스를 통해 CPU에 `인터럽트 벡터`를 보냄
    5. CPU가 인터럽트 요청의 주체를 알게 되고, 해당 장치의 `인터럽트 서비스 루틴` 실행
- PIC를 여러 개 사용해서 더 많은 하드웨어 인터럽트를 관리할 수 있음
    
    

### DMA 입출력

- `DMA`(Direct Memory Access) - 입출력장치와 메모리가 CPU를 거치지 않고 상호작용할 수 있는 입출력 방식
- 시스템 버스에 연결된 `DMA 컨트롤러`가 필요

**DMA 입출력 과정**

1. DMA 컨트롤러에 입출력장치 주소, 수행할 연산(읽기 / 쓰기), 읽거나 쓸 메모리 수조 등 정보로 입출력 작업 명령
2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용, 입출력 작업 수행(필요한 경우 메모리에 직접 접근해서 정보를 읽거나 쓴다)
3. 입출력 작업 완료 후 DMA 컨트롤러는 CPU에 인터럽트 결고 작업이 끝났다고 알림
- `사이클 스틸링` : DMA의 시스템 버스 이용 - 시스템 버스는 공용으로 사용하기 때문에, DMA컨트롤러는 CPU가 시스템 버스를 이용하지 않을 때 마다 혹은 허락을 구하고 시스템 버스를 사용한다.(메모리 접근, 장치 컨트롤러와 상호작용시 시스템 버스를 이용)

**입출력 버스**

- DMA에 시스템 버스를 너무 많이 사용하지 않아도 되도록, DMA 컨트롤러와 장치 컨트롤러 들을 입출력 버스라는 다른 버스에 연결해서 사용
- PCI 버스, PCI Express 버스 등 여러 종류가 있다.