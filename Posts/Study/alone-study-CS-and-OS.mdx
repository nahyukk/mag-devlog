---
title: "[CS] 혼공컴운 - 컴퓨터 구조 파트"
description: "혼공컴운 책 읽고 정리"
date: "2025.01.06 ~ 2025.02.07"
filter: ["CS"]
---

## 컴퓨터 구조 이해하기

### 컴퓨터 구조는 왜 배우나요?

<aside>
  💻 
	- 문제해결 능력 향상 
	- 문법을 넘어 성능, 용량, 비용을 고려하며 개발할 수
  있다.
</aside>

**문제해결**
- 컴퓨터라는 기계에 코드를 ‘입력’만 할 수 있을 수는 없다.
- 컴퓨터 내부를 분석하며 문제 상황 진단과 더 좋은 해결책을 고민하기 위해

**성능, 용량, 비용**
- 서버 컴퓨터를 고를 때 성능, 용량, 비용을 고려해야 한다.
- 물론 클라우드 서비스도 어떤 CPU를 사용할지, 어떤 메로리를 사용할지 판단 해야 함.
- 개발한 프로그램이 어떤 환경에서 어떻게 작동 하는지 잘 이해하고 있어야 함.
- 최적의 컴퓨터 환경을 판단할 수 있어야 함.

### 컴퓨터 구조

**컴퓨터가 이해하는 정보**
- 데이터 : 컴퓨터가 이해하는 숫자, 문자, 동영상 등 정적인 정보
- 명령어 : 데이터를 움직이고 컴퓨터를 작동시키는 정보

**컴퓨터 부품**
- CPU
  - ALU : 계산
  - 레지스터 : 임시 저장장치
  - 제어장치 : 메모리 읽기, 메모리 쓰기, 명령어 해석
- 메모리(RAM, ROM)
  - 현재 실행되는 프로그램의 명령어와 데이터를 저장
  - 값의 위치는 주소로 저장
- 보조기억장치
  - 하드, SSD, USB 등
- 입출력장치
  - 모니터, 키보드, 마우스

→ 메인보드에 연결됨 - 버스라는 통로가 있고 부품을 연결하는 통로는 시스템 버스

- 시스템 버스
  - 주소 버스
  - 데이터 버스
  - 제어 버스

## 데이터

2025년 1월 8일

### 0과 1로 숫자 표현

정보 단위

`비트` 0과 1을 표현하는 가장 작은 단위

1 비트 - 2가지

2비트 - 4가지 … n 비트는 2^n 가지의 정보 표현이 가능하다.

**`이진법`**
이진수의 음수 2의 보수

- 어떤 수를 그보다 큰 2^n에서 뺀 값
- 쉽게 하자면, 모든 0과 1을 뒤집어서 1을 더한 값

`플래그`

- 수가 양수인지 음수인지 구분

**`십육진법`**
- 숫자의 길이가 너무 길어져서 사용
- 이진법으로 변환이 쉬움

2^4 = 16이므로 십육진수 → 이진수 로 표현하려면 4비트가 필요함.

예) 1A2B(16) = 0001101000101011(2)

이진수 → 십육진수 ⇒ 4개씩 끊어서 바꿔주면 된다.

예) 11010101(2) = D5(16)

2025년 1월 9일

### 0과 1로 문자 표현

- 문자 set : 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
- 문자 인코딩: 문자를 0, 1로 변환, 인코딩 후 0, 1로 이루어진 결과값이 `문자코드`가 된다.
- 디코딩: 문자 코드를 사람이 이해할 수 있는 문자로 변환

`아스키 코드`

- 초기 문자 집합 중 하나
- 영어 알파벳, 아라비아 숫자, 일부 특수문자 포함
- 각 7비트로 표현, 2^7 = 128개 문자 표현 가능
  - 8비트 인데 1비트는 parity bit로 오류 검출용
- 표현 가능한 문자 수가 부족하다는 단점

한글 인코딩

- 완성형 인코딩
- 조합형 인코딩

`EUC-KR`

- 대표적인 완성형 인코딩 방식
- 한글 한글자는 16비트 - 16진수로 표현
- 2350개 정도 가능 - 아직 부족함

**유니코드와 UTF-8**

`유니코드`

- 모든 언어를 아우르는 문자 집합
- 통일된 표준 인코딩 방식

→ 유니코드는 글자에 부여된 값 자체를 인코딩 값으로 하지 않음.

- 인코딩 방법으로 UTF-8, UTF-16, UTF-32 등이 있다.

`UTF-8`

16진법으로

0000~007F - 1 바이트로 표현

0080~07FF - 2 바이트로 표현

0800~FFFF - 3 바이트로 표현

10000~10FFFF - 4 바이트로 표현

## 명령어

### 소스 코드

개발자 - 소스코드 -변환→ 명령어 - 컴퓨터

`고급언어` : 사람을 위한 언어 - 대부분의 프로그래밍 언어

`저급언어` : 컴퓨터가 직접 이해하고 실행하는 언어 = 명령어

- 기계어 - 0, 1로 이루어지거나, 십육진수로 표현됨
- 어셈블리어 - 기계어를 사람이 읽기 편한 형태로 번역한 언어
  - 안쓸 것 같지만.. 임베디드, 게임, 정보보안 등 많이 사용함

`컴파일 언어` : 소스코드 전체가 저급언어로 변환되어 실행 - C

- 소스 코드 전체가 저급 언어로 변환되는 과정 = `컴파일`
- 소스코드(고급언어) —컴파일—> `목적코드`(저급언어)

`인터프리터 언어` : 코드가 한 줄씩 실행되는 언어 - Python

- 컴파일언어와 다르게 오류가 있기 전까지 실행
- 대신 컴파일 언어보다 느리다

목적파일 —링킹—> 실행파일 : 여기 조금 이해 못함..

### 명령어의 구조

| **연산 코드** | **오퍼랜드** |
| ------------- | ------------ |

`오퍼랜드` : 연산에 사용할 데이터 - 피연산자

- 연산에 사용할 데이터, 데이터가 저장된 위치
- 많은 경우 데이터가 저장된 위치, 메모리 주소나 레지스터 이름이 담김
- 오퍼랜드 필드 = `주소 필드`
- 한 명령어 안에 없을 수도, 1개만 있을 수도, 2,3개가 있을 수도 있다

`0- 주소 명령어`

| **연산 코드** |
| :----------: |

`1- 주소 명령어`

| **연산 코드** | **오퍼랜드** |
| ------------- | ------------ |

`2- 주소 명령어`

| **연산 코드** | **오퍼랜드** | **오퍼랜드** |
| ------------- | ------------ | ------------ |

`연산코드` : 명령어가 수행할 연산 - 연산자

1. 데이터 전송
   - MOVE, STORE, LOAD(FETCH), PUSH, POP
2. 산술/논리 연산
   - ADD/SUBTRACK/MULTIPLY/DIVIDE, INCREMENT/DEVREMENT, AND/OR/NOT, COMPARE
3. 제어 흐름 변경
   - JUMP, CONDITIONAL JUMP, HALT, CALL, RETURN
4. 입출력 제어
   - READ(INPUT), WRITE(OUTPUT), START IO, TEST IO

- 명령어에 데이터 대신 주소를 담는 이유는 명령어 길이 때문이다. 오퍼 랜드의 길이는 (명렁어 n 비트) - (연산 코드 m 비트)가 된다. 2, 3-주소 명령어가 더 작아진다.
- 예) 한 주소에 16비트를 저장하는 메모리가 있다면 여기 데이터를 저장하고, 오퍼랜드 필드(4비트) 에 메모리 주소 명시로 표현하면 2^16가지의 정보를 담을 수 있다.

`유효주소`

- 연산의 대상이 되는 데이터가 저장된 위치

`주소 지정 방식` - 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법

- `즉시 주소 지정 방식` - **데이터**를 오퍼랜드 필드에 직접 명시
- `직접 주소 지정 방식` - 오퍼랜드 필드에 **유효 주소**를 직접적으로 명시
- `간접 주소 지정 방식` - **유효 주소의 주소**를 오퍼랜드 필드에 명시
- `레지스터 주소 지정 방식` - 연산에 사용할 데이터를 저장한 **레지스터**를 오퍼랜드 필드에 직접 명시 / 일반적으로 메모리에 접근하는 것보다 CPU내부 레지스터에 접근하는 것이 더 빠르다.
- `레지스터 간접 주소 지정 방식` - 연산에 사용할 데이터를 메모리에 저장하고, **유효주소를 저장한 레지스터**를 오퍼랜드 필드에 명시 / 간접 주소 지정방식보다 빠르다.

## CPU의 작동원리

### ALU

- 계산을 하는 부품

**받아들이는 정보**

- 레지스터를 통해 `피연산자`를 받고, 제어장치로부터 수행할 연산을 알려주는 `제어 신호`를 받는다.
- 산술연산, 논리 연산 등 다양한 연산 수행

**내보내는 정보**

- 수행한 `결과` - 특정 숫자, 문자, 메모리 주소
  - 바로 메모리로 가는 게 아니라 레지스터에 저장
    - CPU가 메모리에 접근하는 속도 < 레지스터에 접근하는 속도 기 때문에 CPU가 메모리에 자주 접근하지 않도록(실행 속도를 늦추는 것) 레지스터에 저장하는 것
- 계산 결과와 더불어 `플래그`를 내보냄
  - 추가적인 상태 정보 (예, 계산한 결과는 음수, 오버플로우 등)
    | (대표적인) 플래그 종류 | 예시 |
    | ---------------------- | --------------------------------------------- |
    | **부호 플래그** | 1은 음수, 0은 양수 |
    | **제로 플래그** | 1은 0, 0은 0이 아닌 값 |
    | **캐리 플래그** | 1은 올림수 또는 빌림수 발생, 0은 발생 x |
    | **오버플로우** | 1은 오버플로우 발생, 0은 발생 x |
    | **인터럽트 플래그** | 1은 인터럽트 가능, 0은 불가능 |
    | **슈퍼바이저 플래그** | 1은 커널모드 실행 중, 0은 사용자 모드 실행 중 | \*오버플로우: 연산 결과가 연산 결과를 담을 레지스터보다 큰 상황
  - 플래그 레지스터에 따로 저장
  - 예시) 플래그 레지스터
    | 부호 | 제로 | 캐리 | 오버플로우 | 인터럽트 | 슈퍼바이저 |
    | ---- | ---- | ---- | ---------- | -------- | ---------- |
    | 1 | 0 | 0 | 0 | 0 | 0 |

### 제어 장치

- 제어 신호를 내보내고, 명령어를 해석하는 부품

**받아들이는 정보**

1. `클럭 신호`

   `클럭`: 부품이 움직이는 시간 단위(주기적으로 똑-딱-똑-딱) 디지털 신호..라고 생각하면 되려나?

2. 해석해야 할 `명령어`

   명령어 레지스터에 저장

3. 플래그 레지스터 속 `플래그 값`
4. 시스템 버스 중 제어 버스로 전달된 `제어 신호`

**내보내는 정보**

- CPU 외부로 내보내는 정보 (제어 버스로 제어 신호를 내보낸다는 것)
  - 메모리에 전달하는 제어 신호 - 메모리에 새로운 값을 쓰고 싶을 때
  - 입출력 장치에 전달하는 제어 신호 - 입출력 장치에 새로운 값을 쓰고 싶을 때
- CPU 내부로 내보내는 정보
  - ALU에 전달하는 제어 신호 - 수행할 연산 지시
  - 레지스터에 전달하는 제어 신호 - 레지스터 간 데이터 이동, 레지스터에 저장된 명령어 해석

### 레지스터

1. `프로그램 카운터` (명령어 포인터)
   - 메모리에서 읽어올 명령어의 주소를 저장
2. `메모리 주소 레지스터`
   - 메모리 주소를 저장
3. `메모리 버퍼 레지스터` (메모리 데이터 레지스터)
   - 메모리와 주고 받을 값(데이터, 명령어)를 저장
4. `명령어 레지스터`
   - 방금 메모리에서 읽어온 명령어를 저장
5. 범용 레지스터
   - 데이터와 주소 모두 저장 가능
   - 여러개가 있음
6. 플래그 레지스터
   - ALU 연산 결과에 따른 플래그를 저장

주소 지정 방식

1. 스택 주소 지정 방식
   - 스택과 스택 포인터(스택의 꼭대기를 가르키는 레지스터 = 마지막에 저장한 값)를 이용한 주소 지정 방식
2. 변위 주소 지정 방식
   1. 상대 주소 지정 방식
      - 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
      - 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용
   2. 베이스 레지스터 주소지정 방식
      - 오퍼랜드(사이 거리)와 베이스 레지스터(기준 주소)의 값을 더하여 유효 주소를 얻는 방식

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6ff381ac-b14b-424e-b245-44ff046856c4/ad3c2eb1-5bab-4fda-a378-9d1e670860c0/image.png)

### 명령어 사이클

- 프로그램 속 각각의 명령어들이 실행되는 일정한 반복 주기

1. `인출 사이클` - 메모리에 있는 명령어를 CPU로 가지고 오는 단계
2. `실행 사이클` - CPU로 가져온 명령어를 실행하는 단계
   - 제어장치가 명령어 레지스터에 담긴 값을 해석, 제어 신호를 발생시키는 단계

인출 ↔ 실행

1. `간접 사이클` - 어떤 명령어의 경우 간접 주소를 가져오기 위해 메모리에 한번 더 접근함.

### 인터럽트

- CPU가 수행 중인 작업을 방해하는 신호
- 동기 인터럽트 = 예외(`Exception`)
  - CPU에 의해 발생하는 인터럽트
  - 프로그래밍상의 오류와 같은 예외적인 상항에 마주쳤을 때
  - `폴트` : 예외 처리 직후 예외가 발생한 명령어부터 실행 재개
  - `트랩` : 예외 처리 직후 예외가 발생한 명령어의 다음 명령어 부터 실행 재개
  - `중단abort` : CPU가 실행 중인 프로그램을 강제로 중단
  - `소프트웨어 인터럽트` : 시스템 호출이 발생 했을 때
- 비동기 인터럽트 = `하드웨어 인터럽트`
  - 주로 입출력 장치에 의해 발생하는 인터럽트
  - 알림 역할
  - 키보드, 마우스, 프린터 등등
  - 처리 순서
    1. 입출력장치가 CPU에 `인터럽트 요청 신호`를 보냄
    2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인
    3. CPU는 인터럽트 요청을 확인하고 `인터럽트 플래그`를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
    4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업
    5. CPU는 `인터럽트 벡터`를 참조하여 `인터럽트 서비스 루틴`을 실행
    6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해둔 작업을 복구해 실행 재개
  - `인터럽트 요청 신호` : “끼어들어도 될까요?”
  - `인터럽트 플래그` : 플래그 레지스터가 가능으로 되어 있어야 한다.
    - 불가능으로 설정되어 있어도 `무시할 수 없는 하드웨어 인터럽트`가 우선순위가 높다. ⇒ 하드웨어 고장 같은 거
  - `인터럽트 서비스 루틴` : 인터럽트를 처리하기 위한 프로그램 = `인터럽트 핸들러`
  - `인터럽트 벡터` : 인터럽트 서비스 루틴을 식별하기 위한 정보, 서비스 루틴의 시작 주소를 알 수 있음.
    - 명령어와 데이터로 이루어져있음.
    - 레지스터를 사용하며 실행

## CPU 성능 향상 기법

### 빠른 CPU를 위한 설계 기법

`클럭` : 부품들은 클럭 신호에 따라 움직인다.

- 클럭 속도가 높을 수록 CPU 성능이 좋다. CPU 속도 단위 = 클럭 속도
- 무작정 높다고 좋지는 않다. 왜? 발열 문제!!

→ `코어`와 `스레드` 수를 늘리는 방법

`멀티코어` : CPU하나에 코어(CPU)가 여러개 있다.

- 연산속도가 코어 수에 비례하여 증가하지는 않음.(팀플을 생각해보자..)
- 코어마다 처리할 명령어를 얼마나 적절하게 분배하느냐가 연산 속도에 큰 영향을 준다.

`스레드` : 실행 흐름의 단위(사전적)

- `하드웨어적 스레드` : 하나의 코어가 동시에 처리하는 명령어 단위 (예, 8코어 16스레드 cpu ⇒ 코어 하나당 2 개의 하드웨어 스레드를 처리)
- `소프트웨어적 스레드` : 하나의 프로그램에서 독립적으로 실행되는 단위
  1. 사용자로 부터 입력받은 내용을 화면에 보여 주는 기능
  2. 사용자가 입력한 내용이 맞춤법에 맞는지 검사하는 기능
  3. 사용자가 입력한 내용을 수시로 저장하는 기능
  - 을 각각 스레드로 만들어서 동시에 실행할 수 있다.

`멀티스레드 프로세서`

- 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
- 레지스터 세트가 코어 당 2개씩 있다면 2스레드가 되는 것 처럼.. 그림에 나와있음.

### 명령어 병렬 처리 기법

CPU가 놀지 않고 시간을 알뜰하게 쓰면서 작동하게 만드는 것

`명령어 파이프라인`

명령어 처리 과정

- 명령어 인출 → 명령어 해석 → 실행 → 결과 저장
- 같은 단계가 겹치지 않는다면 CPU는 각 단계를 동시에 실행할 수 있다.
- 한 명령어가 끝나고 다음 명령어가 실행되는 것보다 훨씬 빠름
- `파이프라인 위험` : 성능 향상에 실패하는 경우
  - 데이터 위험 : 데이터 의존성에 의해 발생, 이전 명령어를 끝까지 실행해야 실행할 수 있는 경우 → 파이프라인이 제대로 작동하지 않음
  - 제어 위험 : 프로그램 카운터의 갑작스러운 변화로 발생(번지수 분기)
  - 구조적 위험 : 서로 다른 명령어가 ALU, 레지스터 등 CPU 부품을 사용하려고 할 때 발생

`슈퍼 스칼라`

- 여러개의 명령어 파이프라인이 있는 것
- 파이프라인 위험이 더 까다롭게 됨

`비순차적 명령어 처리`

- 대부분 CPU가 차용
- 합법적 새치기 기법
- 명령어들이 어떤 명령어와 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는 명령어는 어떤게 있는지 판단해야 한다.

### CISC 와 RISC

명령어 집합 = `명령어 집합 구조(ISA)` - CPU가 이해할 수 있는 명령어들의 모음

- CPU 마다 이해하고 실행할 수 있는 명령어가 다르니, 같은 명령어를 각자 컴파일하면 나오는 어셈블리어도 달라진다.
- ISA가 다르다는 것은 명령어 뿐 아니라 그 명령어를 처리하는 CPU 하드웨어의 설계에도 큰 영향을 미친다.

`CISC`(Complex Instruction Set Computer)

- 복잡하고 다양한 수의 `가변 길이 명령어` 집합을 활용
- 프로그램을 실행하는 명령어 수가 적다 = 컴파일된 프로그램의 크기가 작다
  - 메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높았음.
- 다양한 주소 지정 방식
- 규격화되지 않은 명령어(여러 클럭에 걸쳐 명령어 수행)라 파이프라이닝이 어려워짐. → 성능 측면 문제
- 어려운 명령어를 수행할 수 있지만, 현실은 쓰는 명령어를 많이 쓰는 걸

`RISC`(Reduced Instruction Set Computer)

- 짧고 규격화된 `고정 길이 명령어`를 활용
- 프로그램을 이루는 명령어 수가 많음
- 원활한 파이프라이닝(1클럭 내외로 명령어 수행)

## 메모리와 캐시 메모리

### RAM의 특징과 종류

**RAM의 특징**

- 실행할 프로그램의 명령어와 데이터가 저장
- 전원을 끄면 저장된 내용이 사라지는 `휘발성 저장장치`
  - `비휘발성 저장장치` : 하드디스크, SSD, CD-ROM, USB 등 보조기억장치들
- CPU는 보조기억장치에 직접 접근을 못함 ⇒ 실행하려면 RAM으로 복사해서 저장한 뒤 실행

**RAM의 용량과 성능**

- RAM 용량이 커지만 프로그램 실행 속도가 어느 정도 증가하지만 속도가 비례해서 증가하지는 않음

**RAM의 종류**

- `DRAM`
  - 시간이 지나면 저장된 데이터가 점차 사라짐.
  - 일정주기로 데이터를 재활성화(다시 저장)해야함.
  - 하지만 쓰는 이유? 소비 전력 낮고, 싸고, 집적도 높음.

- `SRAM`
  - 시간이 지나도 데이터가 사라지지 않음
  - 속도가 DRAM보다 빠름
  - 집적도가 낮고, 소비 전력도 크고, 비쌈
  - 대용량일 필요 없지만 속도가 빨라야 하는 `캐시 메모리` 같은 거에 사용

- `SDRAM` - SRAM과 관련 없음
  - 클럭 신호와 동기화된, 발전된 형태의 DRAM
	
- `DDR SDRAM` - 최근 RAM
  - 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
  - 너비가 2배, 한 클럭당 두번씩 CPU와 데이터를 주고 받음
  - DDR2, DDR3 등 있음


![Image](https://blog.kakaocdn.net/dn/dCp9Uq/btqwhTDhICS/2lHkVdCkdLGCqF0HudziT0/img.png)